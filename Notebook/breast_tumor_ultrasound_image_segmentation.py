# -*- coding: utf-8 -*-
"""BREAST TUMOR ULTRASOUND IMAGE SEGMENTATION.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1KUF-kezL-7IKZ5ILzuAnLusjez7G64A8
"""

#Required module
#pip install openpyxl

import pandas as pd
import cv2

#define .xlsx filename and folder containing images and masks
info_filename = r'BrEaST-Lesions-USG-clinical-data-Sep-2023-with-data-dictionary-v2-Nov-7-2023.xlsx'
images_and_masks_foldername = r'BrEaST-Lesions_USG-images_and_masks/'

#read .xlsx file with clinical data
breast_dataset = pd.read_excel(info_filename, sheet_name='BrEaST-Lesions-USG clinical dat')

for i in breast_dataset.index:
    #parse milti-label columns
    breast_dataset.at[i, 'Tissue_composition'] = breast_dataset.loc[i,'Tissue_composition'].split('&')
    breast_dataset.at[i, 'Signs'] = breast_dataset.loc[i,'Signs'].split('&')
    breast_dataset.at[i, 'Symptoms'] = breast_dataset.loc[i,'Symptoms'].split('&')
    breast_dataset.at[i, 'Margin'] = breast_dataset.loc[i,'Margin'].split('&')
    breast_dataset.at[i, 'Interpretation'] = breast_dataset.loc[i,'Interpretation'].split('&')
    breast_dataset.at[i, 'Diagnosis'] = breast_dataset.loc[i,'Diagnosis'].split('&')

#read image
breast_dataset.at[i, 'Image_filename']  = cv2.imread(images_and_masks_foldername+breast_dataset.loc[i,'Image_filename'], cv2.IMREAD_UNCHANGED)

# Read the grayscale image
gray_image = cv2.imread(images_and_masks_foldername + breast_dataset.loc[i, 'Mask_tumor_filename'], cv2.IMREAD_GRAYSCALE)

# Threshold the grayscale image to generate a binary mask
_, binary_mask = cv2.threshold(gray_image, 0, 255, cv2.THRESH_BINARY)

# Store the binary mask in the dataset
breast_dataset.at[i, 'Mask_tumor_filename'] = binary_mask

#read other mask
if not isinstance(breast_dataset.loc[i,'Mask_other_filename'], float):
        masks_bool = []
        for mask_path in breast_dataset.loc[i,'Mask_other_filename'].split('&'):
            masks_bool.append(cv2.imread(images_and_masks_foldername+mask_path, cv2.IMREAD_GRAYSCALE)>0)
        breast_dataset.at[i, 'Mask_other_filename'] = masks_bool
else:
        breast_dataset.at[i, 'Mask_other_filename'] = []

#columns rename
breast_dataset.rename(columns={"Image_filename": "Image", "Mask_tumor_filename": "Mask_tumor", "Mask_other_filename": "Mask_other"})

import matplotlib.pyplot as plt
import cv2

def visualize_images(image_paths, titles=None):
    num_images = len(image_paths)
    fig, axes = plt.subplots(1, num_images, figsize=(10, 5))
    for i, image_path in enumerate(image_paths):
        try:
            image = cv2.imread(image_path)
            if image is not None:
                axes[i].imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))
                axes[i].axis('off')
                if titles is not None:
                    axes[i].set_title(titles[i])
            else:
                print(f"Error reading image: {image_path}")
        except Exception as e:
            print(f"Error processing image: {image_path}\n{str(e)}")
    plt.show()

# Example usage
image_paths = [
    '/content/drive/MyDrive/BrEaST-Lesions_USG-images_and_masks/case001_tumor.png',
    '/content/drive/MyDrive/BrEaST-Lesions_USG-images_and_masks/case006.png',
    '/content/drive/MyDrive/BrEaST-Lesions_USG-images_and_masks/case020.png'
]
titles = ['Image 1', 'Image 2', 'Image 3']  # Optional titles for the images
visualize_images(image_paths, titles)

import cv2
#Code to check the size of an image
# Load the image
image_path = '/content/drive/MyDrive/BrEaST-Lesions_USG-images_and_masks/case017_tumor.png'
image = cv2.imread(image_path)

# Check if the image is loaded successfully
if image is not None:
    # Get the dimensions of the image
    height, width, channels = image.shape
    print(f"Image dimensions: Height={height}, Width={width}, Channels={channels}")
else:
    print("Error: Failed to load the image.")

#Resizing the images to 256 x 256
import cv2
import os

def resize_images(input_folder, output_folder, target_size=(256, 256)):
    # Create the output folder if it doesn't exist
    os.makedirs(output_folder, exist_ok=True)

    # Iterate over the images in the input folder
    for filename in os.listdir(input_folder):
        # Read the image
        img_path = os.path.join(input_folder, filename)
        img = cv2.imread(img_path)

        # Resize the image
        resized_img = cv2.resize(img, target_size)

        # Save the resized image to the output folder
        output_path = os.path.join(output_folder, filename)
        cv2.imwrite(output_path, resized_img)

# Example usage
input_folder = '/content/drive/MyDrive/BrEaST-Lesions_USG-images_and_masks'
output_folder = '/content/resized_images'
resize_images(input_folder, output_folder)

#To check if image has been resized
import cv2
# Load the image
image_path = '/content/resized_images/case017_tumor.png'
image = cv2.imread(image_path)

# Check if the image is loaded successfully
if image is not None:
    # Get the dimensions of the image
    height, width, channels = image.shape
    print(f"Image dimensions: Height={height}, Width={width}, Channels={channels}")
else:
    print("Error: Failed to load the image.")

import os

# Define the path to the resized_images folder
resized_images_folder = '/content/resized_images'

# Define the subdirectory names for images and masks
image_subdirectory = 'images'
mask_subdirectory = 'masks'

# Check if the subdirectories exist
image_subdirectory_path = os.path.join(resized_images_folder, image_subdirectory)
mask_subdirectory_path = os.path.join(resized_images_folder, mask_subdirectory)

if os.path.exists(image_subdirectory_path):
    print(f"Subdirectory '{image_subdirectory}' exists for images.")
else:
    print(f"Subdirectory '{image_subdirectory}' does not exist for images.")

if os.path.exists(mask_subdirectory_path):
    print(f"Subdirectory '{mask_subdirectory}' exists for masks.")
else:
    print(f"Subdirectory '{mask_subdirectory}' does not exist for masks.")

#Create sub directory to the resized masks
import os

# Define the path to the resized_images directory
resized_images_dir = '/content/resized_images'

# Define the path to the masks directory within resized_images
masks_dir = os.path.join(resized_images_dir, 'masks')

# Check if the masks directory exists, if not, create it
if not os.path.exists(masks_dir):
    os.makedirs(masks_dir)
    print("Masks directory created successfully.")
else:
    print("Masks directory already exists.")

#Define sub directory to the resized images
import os

# Define the path to the resized_images directory
resized_images_dir = '/content/resized_images'

# Define the path to the images directory within resized_images
images_dir = os.path.join(resized_images_dir, 'images')

# Check if the images directory exists, if not, create it
if not os.path.exists(images_dir):
    os.makedirs(images_dir)
    print("Images directory created successfully.")
else:
    print("Images directory already exists.")

import os
import shutil

# Define the path to the resized_images folder
resized_images_folder = '/content/resized_images'

# Define the subdirectory names for images and masks
image_subdirectory = 'images'
mask_subdirectory = 'masks'

# Create the image subdirectory if it doesn't exist
image_subdirectory_path = os.path.join(resized_images_folder, image_subdirectory)
os.makedirs(image_subdirectory_path, exist_ok=True)

# Create the mask subdirectory if it doesn't exist
mask_subdirectory_path = os.path.join(resized_images_folder, mask_subdirectory)
os.makedirs(mask_subdirectory_path, exist_ok=True)

# Get a list of all files in the resized_images folder
all_files = os.listdir(resized_images_folder)

# Move files to their respective subdirectories
for filename in all_files:
    src = os.path.join(resized_images_folder, filename)
    if'_tumor' in filename or '_other1' in filename or '_other2' in filename:
        # Move mask files to the mask subdirectory
        dst = os.path.join(mask_subdirectory_path, filename)
        shutil.move(src, dst)
        print(f"Moved mask file: {filename} to {mask_subdirectory}")
    elif filename.endswith('.png'):
        # Move image files to the images subdirectory
        dst = os.path.join(image_subdirectory_path, filename)
        shutil.move(src, dst)
        print(f"Moved image file: {filename} to {image_subdirectory}")

print("Files have been moved to their respective subdirectories.")

#To extract masks from the images subdirectory and directing them to the masks subdirectory
import os
import shutil

# Define the path to the resized_images folder
resized_images_folder = '/content/resized_images'

# Define the subdirectory names for images and labels
image_subdirectory = 'images'
mask_subdirectory = 'masks'

# Create the image subdirectory if it doesn't exist
image_subdirectory_path = os.path.join(resized_images_folder, image_subdirectory)
os.makedirs(image_subdirectory_path, exist_ok=True)

# Create the mask subdirectory if it doesn't exist
mask_subdirectory_path = os.path.join(resized_images_folder, mask_subdirectory)
os.makedirs(mask_subdirectory_path, exist_ok=True)

# Get a list of all files in the images subdirectory
image_files = os.listdir(image_subdirectory_path)

# Move masked images to the masks subdirectory
for filename in image_files:
    if '_tumor' in filename or '_other1' in filename or '_other2' in filename or '_other3' in filename or '_other4' in filename:
        src = os.path.join(image_subdirectory_path, filename)
        dst = os.path.join(mask_subdirectory_path, filename)
        shutil.move(src, dst)
        print(f"Moved masked image file: {filename} to {mask_subdirectory}")

print("Masked images have been moved to the masks subdirectory.")

#To visualize images in the images subdirectory in the resized_images directory
import os
import matplotlib.pyplot as plt
import matplotlib.image as mpimg

# Define the path to the images subdirectory
image_subdirectory = '/content/resized_images/images'

# Get a list of all files in the images subdirectory
image_files = os.listdir(image_subdirectory)

# Select the first 5 image files
selected_images = image_files[:5]

# Visualize the selected images
plt.figure(figsize=(15, 8))
for i, filename in enumerate(selected_images, 1):
    img_path = os.path.join(image_subdirectory, filename)
    img = mpimg.imread(img_path)
    plt.subplot(1, 5, i)
    plt.imshow(img)
    plt.title(filename)
    plt.axis('off')

plt.show()

#To synthesize ood data, using the last 6 images and masks from resized_images directory
import os
import shutil
import imgaug.augmenters as iaa
from PIL import Image
import numpy as np

# Define paths
resized_images_directory = '/content/resized_images'
synthesized_data_directory = '/content/synthesized_data'
ood_images_directory = os.path.join(synthesized_data_directory, 'ood_images')
ood_masks_directory = os.path.join(synthesized_data_directory, 'ood_masks')

# Ensure directories exist
os.makedirs(ood_images_directory, exist_ok=True)
os.makedirs(ood_masks_directory, exist_ok=True)

# Get the last 6 images and masks
image_files = sorted(os.listdir(os.path.join(resized_images_directory, 'images')))[-6:]
mask_files = sorted(os.listdir(os.path.join(resized_images_directory, 'masks')))[-6:]

# Define augmentation pipeline
augmentation_pipeline = iaa.Sequential([
    iaa.Affine(rotate=(-10, 10)),  # Rotate images randomly between -10 to 10 degrees
    iaa.GaussianBlur(sigma=(0.0, 1.0)),  # Apply Gaussian blur with a sigma between 0.0 to 1.0
    iaa.AdditiveGaussianNoise(scale=(0, 0.05*255)),  # Add Gaussian noise with a scale of 0 to 0.05 times 255
])

# Synthesize OOD examples
for image_file, mask_file in zip(image_files, mask_files):
    src_image = os.path.join(resized_images_directory, 'images', image_file)
    src_mask = os.path.join(resized_images_directory, 'masks', mask_file)
    dst_image = os.path.join(ood_images_directory, image_file)
    dst_mask = os.path.join(ood_masks_directory, mask_file)

    # Augment image
    image = Image.open(src_image)
    augmented_image = augmentation_pipeline(image=np.array(image))
    augmented_image = Image.fromarray(augmented_image)

    # Copy augmented image and mask to ood directories
    augmented_image.save(dst_image)
    shutil.copy(src_mask, dst_mask)

print("OOD images and masks synthesized successfully with augmentation.YAAAAYYYYY!!!!")

#To visualize 5 images from ood_images subdirectory
import os
import matplotlib.pyplot as plt
import matplotlib.image as mpimg

# Define the path to the ood_images subdirectory
ood_images_directory = '/content/synthesized_data/ood_images'

# Get a list of all files in the ood_images subdirectory
ood_image_files = os.listdir(ood_images_directory)

# Select the first 5 image files
selected_ood_images = ood_image_files[:5]

# Visualize the selected images
plt.figure(figsize=(15, 8))
for i, filename in enumerate(selected_ood_images, 1):
    img_path = os.path.join(ood_images_directory, filename)
    img = mpimg.imread(img_path)
    plt.subplot(1, 5, i)
    plt.imshow(img)
    plt.title(filename)
    plt.axis('off')

plt.show()

import os
#Renaming the ood data such it it is a continuation from the original dataset to prevent duplicates
# Directory containing synthesized OOD images and masks
ood_images_dir = "/content/synthesized_data/ood_images"
ood_masks_dir = "/content/synthesized_data/ood_masks"

# Define the range for the new case numbers
ood_start_index = 257
ood_end_index = 262

# Initialize a counter for the OOD cases
ood_counter = 0

# Iterate over the images directory
for filename in os.listdir(ood_images_dir):
    if filename.endswith(".png"):  # Adjust the extension if necessary
        # Increment the counter
        ood_counter += 1

        # Check if the counter is within the desired range
        if 1 <= ood_counter <= 6:
            # Construct the new filename
            new_filename = f"case{ood_start_index + ood_counter - 1}.png"  # Adjust the extension if necessary
            # Construct the full paths
            old_filepath = os.path.join(ood_images_dir, filename)
            new_filepath = os.path.join(ood_images_dir, new_filename)

            # Rename the file
            os.rename(old_filepath, new_filepath)

            # Print the renaming information
            print(f"Renamed {filename} to {new_filename}")

# Reset the counter for the masks
ood_counter = 0

# Iterate over the masks directory
for filename in os.listdir(ood_masks_dir):
    if filename.endswith(".png"):  # Adjust the extension if necessary
        # Increment the counter
        ood_counter += 1

        # Check if the counter is within the desired range
        if 1 <= ood_counter <= 6:
            # Construct the new filename
            new_filename = f"case{ood_start_index + ood_counter - 1}_tumor.png"  # Adjust the extension if necessary
            # Construct the full paths
            old_filepath = os.path.join(ood_masks_dir, filename)
            new_filepath = os.path.join(ood_masks_dir, new_filename)

            # Rename the file
            os.rename(old_filepath, new_filepath)

            # Print the renaming information
            print(f"Renamed {filename} to {new_filename}")

print("Renaming completed.")

#This is to merge the resized_images and synthesized_ood
import os
import shutil

# Define paths
resized_images_directory = '/content/resized_images'
synthesized_data_directory = '/content/synthesized_data'
merged_dataset_directory = '/content/merged_dataset'
merged_images_directory = os.path.join(merged_dataset_directory, 'merged_images')
merged_masks_directory = os.path.join(merged_dataset_directory, 'merged_masks')

# Create merged_dataset_directory if it doesn't exist
os.makedirs(merged_dataset_directory, exist_ok=True)
os.makedirs(merged_images_directory, exist_ok=True)
os.makedirs(merged_masks_directory, exist_ok=True)

# Copy images from resized_images/images to merged_dataset/merged_images
for filename in os.listdir(os.path.join(resized_images_directory, 'images')):
    src = os.path.join(resized_images_directory, 'images', filename)
    dst = os.path.join(merged_images_directory, filename)
    shutil.copy(src, dst)
    print(f"Copied image: {filename} to merged_images")

# Copy images from synthesized_data/ood_images to merged_dataset/merged_images
for filename in os.listdir(os.path.join(synthesized_data_directory, 'ood_images')):
    src = os.path.join(synthesized_data_directory, 'ood_images', filename)
    dst = os.path.join(merged_images_directory, filename)
    shutil.copy(src, dst)
    print(f"Copied image: {filename} to merged_images")

# Copy masks from resized_images/masks to merged_dataset/merged_masks
for filename in os.listdir(os.path.join(resized_images_directory, 'masks')):
    src = os.path.join(resized_images_directory, 'masks', filename)
    dst = os.path.join(merged_masks_directory, filename)
    shutil.copy(src, dst)
    print(f"Copied mask: {filename} to merged_masks")

# Copy masks from synthesized_data/ood_masks to merged_dataset/merged_masks
for filename in os.listdir(os.path.join(synthesized_data_directory, 'ood_masks')):
    src = os.path.join(synthesized_data_directory, 'ood_masks', filename)
    dst = os.path.join(merged_masks_directory, filename)
    shutil.copy(src, dst)
    print(f"Copied mask: {filename} to merged_masks")

print("Merge completed successfully.")

!git clone https://github.com/MIC-DKFZ/nnUNet.git /content/nnUNetFrame/nnUNet

# Commented out IPython magic to ensure Python compatibility.
# %cd /content/nnUNetFrame/nnUNet
!pip install -e .
!pip install numpy scipy SimpleITK batchgenerators

import os

# Navigate to the nnUNet subfolder
nnunet_dir = '/content/nnUNetFrame/nnUNet'
os.chdir(nnunet_dir)

# Install hiddenlayer package
!pip install --upgrade git+https://github.com/FabianIsensee/hiddenlayer.git

import os

# Define the root directory
root_dir = '/content/nnUNetFrame'

# Create nnUNet subfolder
nnunet_dir = os.path.join(root_dir, 'nnUNet')
os.makedirs(nnunet_dir, exist_ok=True)

# Create dataset subfolder
dataset_dir = os.path.join(root_dir, 'dataset')
os.makedirs(dataset_dir, exist_ok=True)

# Create subfolders under dataset
subfolders = ['nnUNet_raw', 'nnUNet_preprocessed', 'nnUNet_results']
for subfolder in subfolders:
    subfolder_path = os.path.join(dataset_dir, subfolder)
    os.makedirs(subfolder_path, exist_ok=True)

# Create subfolders under nnUNet_raw
nnunet_raw_dir = os.path.join(dataset_dir, 'nnUNet_raw')
raw_subfolders = ['nnUNet_raw_data', 'nnUNet_cropped_data']
for subfolder in raw_subfolders:
    subfolder_path = os.path.join(nnunet_raw_dir, subfolder)
    os.makedirs(subfolder_path, exist_ok=True)

print("Folder structure created successfully.")

# Commented out IPython magic to ensure Python compatibility.
#To set up environments in colab
# %env nnUNet_raw=/content/nnUNetFrame/dataset/nnUNet_raw
# %env nnUNet_preprocessed=/content/nnUNetFrame/dataset/nnUNet_preprocessed
# %env nnUNet_results=/content/nnUNetFrame/dataset/nnUNet_results

#To convert images and corresponding ground truth masks to nifti format
import os
import shutil
import nibabel as nib
import numpy as np
import cv2

# Define paths
merged_dataset_directory = '/content/merged_dataset'
nnunet_raw_data_dir = '/content/nnUNetFrame/dataset/nnUNet_raw/nnUNet_raw_data'
nifti_images_dir = os.path.join(nnunet_raw_data_dir, 'nifti_images')
nifti_masks_dir = os.path.join(nnunet_raw_data_dir, 'nifti_masks')

# Function to load image data
def load_image(input_path):
    # Load image using OpenCV
    image = cv2.imread(input_path, cv2.IMREAD_GRAYSCALE)  # Load image as grayscale
    return image

# Function to convert image or mask  to NIfTI format
def convert_to_nifti(input_directory, output_type):
    # Define output directory for NIfTI files
    output_nifti_directory = os.path.join(nnunet_raw_data_dir, f'nifti_{output_type}')

    # Create output directory for NIfTI files if it doesn't exist
    os.makedirs(output_nifti_directory, exist_ok=True)

    # Determine input directory for images or masks
    if output_type == 'images':
        input_directory = os.path.join(input_directory, 'merged_images')
    elif output_type == 'masks':
        input_directory = os.path.join(input_directory, 'merged_masks')

    # Function to convert image or mask to NIfTI format
    def convert_to_nifti_single(input_path, output_path):
        # Load image or mask data
        data = load_image(input_path)

        # Convert data type to integer (for masks)
        if output_type == 'masks':
            data = data.astype(np.int16)

        # Create NIfTI image object
        nifti_img = nib.Nifti1Image(data, np.eye(4))  # Assuming identity affine matrix

        # Save NIfTI image
        nib.save(nifti_img, output_path)
        print(f"Saved NIfTI {output_type} image: {output_path}")

    # Iterate over files in input directory
    for filename in os.listdir(input_directory):
        input_file = os.path.join(input_directory, filename)
        output_file = os.path.join(output_nifti_directory, f"{os.path.splitext(filename)[0]}.nii.gz")  # Output file path (with .nii.gz extension)
        convert_to_nifti_single(input_file, output_file)

# Convert images to NIfTI format
convert_to_nifti(merged_dataset_directory, 'images')

# Convert labels to NIfTI format
convert_to_nifti(merged_dataset_directory, 'masks')

print("Conversion completed. NIfTI files created.")

# Move NIfTI images and masks to nnUNet_raw_data directory
os.makedirs(nifti_images_dir, exist_ok=True)
os.makedirs(nifti_masks_dir, exist_ok=True)

# Move NIfTI images
for filename in os.listdir(os.path.join(nnunet_raw_data_dir, 'nifti_images')):
    source = os.path.join(nnunet_raw_data_dir, 'nifti_images', filename)
    dest = os.path.join(nifti_images_dir, filename)
    shutil.move(source, dest)

# Move NIfTI labels
for filename in os.listdir(os.path.join(nnunet_raw_data_dir, 'nifti_masks')):
    source = os.path.join(nnunet_raw_data_dir, 'nifti_masks', filename)
    dest = os.path.join(nifti_masks_dir, filename)
    shutil.move(source, dest)

print("NIfTI files moved to nnUNet_raw_data directory.")

#Rename the images and masks in the nnUNet format
import os

# Directory containing the nifti images and masks
images_dir = "/content/nnUNetFrame/dataset/nnUNet_raw/nnUNet_raw_data/nifti_images"
masks_dir = "/content/nnUNetFrame/dataset/nnUNet_raw/nnUNet_raw_data/nifti_masks"

# Iterate over the range of indices from 1 to 262
for i in range(1, 263):
    # Construct the filenames for images and labels
    image_filename = f"BT_{i:03d}_0000.nii.gz"
    mask_filename = f"BT_{i:03d}.nii.gz"

    # Construct the full paths for images and masks
    image_old_path = os.path.join(images_dir, f"case{i:03d}.nii.gz")
    mask_old_path = os.path.join(masks_dir, f"case{i:03d}_tumor.nii.gz")

    image_new_path = os.path.join(images_dir, image_filename)
    mask_new_path = os.path.join(masks_dir, mask_filename)

    # Skip if the image file or mask file does not exist
    if not os.path.exists(image_old_path) or not os.path.exists(mask_old_path):
        print(f"Image or mask file does not exist for case{i:03d}. Skipping... duuuhhh")
        continue

    # Skip if the mask file ends with _other1.nii.gz, _other2.nii.gz, _other3.nii.gz, or _other4.nii.gz
    if mask_old_path.endswith("_other1.nii.gz") or mask_old_path.endswith("_other2.nii.gz") or mask_old_path.endswith("_other3.nii.gz") or mask_old_path.endswith("_other4.nii.gz"):
        print(f"Mask file {mask_old_path} ends with _otherX.nii.gz. Skipping...  obviously")
        continue

    # Rename the images and masks
    os.rename(image_old_path, image_new_path)
    os.rename(mask_old_path, mask_new_path)

print("Renaming completed.")

import os
##To delete files that start with 'case' because indiscrepancies ie, no corresponding masks, or too many corresponding mask (ie. those that have been skipped)
# Directory containing the nifti images and masks
images_dir = "/content/nnUNetFrame/dataset/nnUNet_raw/nnUNet_raw_data/nifti_images"
masks_dir = "/content/nnUNetFrame/dataset/nnUNet_raw/nnUNet_raw_data/nifti_masks"

# Delete files starting with 'case' in nifti_images directory
for filename in os.listdir(images_dir):
    if filename.startswith("case"):
        file_path = os.path.join(images_dir, filename)
        os.remove(file_path)

# Delete files starting with 'case' in nifti_masks directory
for filename in os.listdir(masks_dir):
    if filename.startswith("case"):
        file_path = os.path.join(masks_dir, filename)
        os.remove(file_path)

print("Deletion completed. Easier work wooohooo!")

import os
import SimpleITK as sitk
import numpy as np

# Define the labels for each region
Background_label = 0  # Blue
Tumor_label = 1  # Red

# Define the directory paths for masks and labels
mask_dir = '/content/nnUNetFrame/dataset/nnUNet_raw/nnUNet_raw_data/nifti_masks'
label_dir = '/content/nnUNetFrame/dataset/nnUNet_raw/nnUNet_raw_data/nifti_labels'

# Get list of mask files
mask_files = os.listdir(mask_dir)

# Iterate through each mask
for mask_file in mask_files:
    # Load mask image
    mask_path = os.path.join(mask_dir, mask_file)
    mask_img = sitk.ReadImage(mask_path)

    print(f"Loaded mask: {mask_file}")

    # Convert SimpleITK image to numpy array
    mask_np = sitk.GetArrayFromImage(mask_img)

    print("Converted mask to numpy array")

    # Create a new label image
    label_img = np.zeros_like(mask_np)

    # Assign labels to regions
    label_img[mask_np == 0] = Background_label  # Background
    label_img[mask_np != 0] = Tumor_label  # Tumor region (assuming any non-zero pixel belongs to tumor)

    print("Assigned labels to regions")

    # Save label image
    label_file = mask_file.replace('.nii.gz', '.nii.gz')  # Modify the label filename
    label_path = os.path.join(label_dir, label_file)
    label_img_nifti = sitk.GetImageFromArray(label_img)
    sitk.WriteImage(label_img_nifti, label_path)

    print(f"Saved label image: {label_file}")

import os
import nibabel as nib
import matplotlib.pyplot as plt

# Define the directory paths for images and labels
image_dir = '/content/nnUNetFrame/dataset/nnUNet_raw/nnUNet_raw_data/nifti_images'
label_dir = '/content/nnUNetFrame/dataset/nnUNet_raw/nnUNet_raw_data/nifti_labels'

# Choose an image file to visualize (replace 'image_file' with the actual file name)
image_file = 'BT_048_0000.nii.gz'
label_file = 'BT_048.nii.gz'

# Load the image and corresponding label
image_path = os.path.join(image_dir, image_file)
label_path = os.path.join(label_dir, label_file)

image_data = nib.load(image_path).get_fdata()
label_data = nib.load(label_path).get_fdata()

# Print the shape of the image data
print("Image data shape:", image_data.shape)

# Print the shape of the label data
print("Label data shape:", label_data.shape)

# Visualize the image and label
plt.figure(figsize=(12, 6))

# Plot the image
plt.subplot(1, 2, 1)
plt.imshow(image_data, cmap='gray')
plt.title('Ultrasound Image')

# Plot the label
plt.subplot(1, 2, 2)
plt.imshow(label_data, cmap='jet', vmin=0, vmax=3)  # Assuming 4 labels
plt.title('Label Image')

plt.show()

#To split the dataset into imagesTr, labelsTr(for training) and imagesTs (for testing)
import os
import shutil
import random

# Function to split dataset
def split_dataset(images_dir, labels_dir, train_ratio=0.8, test_ratio=0.2, seed=42):
    random.seed(seed)

    # Get list of filenames
    image_filenames = os.listdir(images_dir)

    # Shuffle filenames
    random.shuffle(image_filenames)

    # Calculate number of images for each set
    num_images = len(image_filenames)
    num_train = int(train_ratio * num_images)
    num_test = num_images - num_train

    # Split filenames into sets
    train_images = image_filenames[:num_train]
    test_images = image_filenames[num_train:]

    return train_images, test_images

# Define paths
nnunet_raw_data_dir = '/content/nnUNetFrame/dataset/nnUNet_raw/nnUNet_raw_data'
nifti_images_dir = os.path.join(nnunet_raw_data_dir, 'nifti_images')
nifti_labels_dir = os.path.join(nnunet_raw_data_dir, 'nifti_labels')

# Split dataset
train_images, test_images = split_dataset(nifti_images_dir, nifti_labels_dir)

# Create Dataset001_BreastTumor Directory
nnunet_raw_dir = '/content/nnUNetFrame/dataset/nnUNet_raw'
dataset001_BreastTumor_dir = os.path.join(nnunet_raw_dir, 'Dataset001_BreastTumor')
os.makedirs(dataset001_BreastTumor_dir, exist_ok=True)

# Define directories for sets in Dataset001_BrainTumor
images_tr_dir = os.path.join(dataset001_BreastTumor_dir, 'imagesTr')
labels_tr_dir = os.path.join(dataset001_BreastTumor_dir, 'labelsTr')
images_ts_dir = os.path.join(dataset001_BreastTumor_dir, 'imagesTs')

# Create directories if they don't exist
os.makedirs(images_tr_dir, exist_ok=True)
os.makedirs(labels_tr_dir, exist_ok=True)
os.makedirs(images_ts_dir, exist_ok=True)

# Move images and labels to respective directories
for filename in train_images:
    image_src = os.path.join(nifti_images_dir, filename)
    label_src = os.path.join(nifti_labels_dir, filename.replace('_0000.nii.gz', '.nii.gz'))

    if os.path.exists(image_src) and os.path.exists(label_src):
        image_dest = os.path.join(images_tr_dir, filename)
        label_dest = os.path.join(labels_tr_dir, filename.replace('_0000.nii.gz', '.nii.gz'))
        shutil.move(image_src, image_dest)
        shutil.move(label_src, label_dest)

for filename in test_images:
    image_src = os.path.join(nifti_images_dir, filename)
    if os.path.exists(image_src):
        image_dest = os.path.join(images_ts_dir, filename)
        shutil.move(image_src, image_dest)

print("Dataset split into imagesTr, labelsTr, and imagesTs in Dataset001_BreastTumor directory.")

import json

def generate_dataset_json(output_file, channel_names, labels, dataset_name, description, reference, release, license, additional_params, num_training, file_ending):
    dataset_info = {
        "channel_names": channel_names,
        "labels": labels,
        "dataset_name": dataset_name,
        "description": description,
        "reference": reference,
        "release": release,
        "license": license,
        "additional_params": additional_params,
        "numTraining": num_training,
        "file_ending": file_ending
    }

    with open(output_file, 'w') as f:
        json.dump(dataset_info, f, indent=4)

# Define dataset information
channel_names = {
    0: 'ultrasound'  # Since breast ultrasound scans are typically grayscale images, there is only one channel
}
labels = {
    'background': 0,  #blue
    'tumor': 1,  #red
}
dataset_name = 'BrEast-Lesions_USG_images_and_masks'
description = """Dataset containing breast ultrasound scans with labels and annotations.
Preprocessing:
- Resizing: Images were resized to a fixed resolution of (256, 256) to standardize the input size for the neural network model.
- Augmentation: Augmentation techniques such as rotation, flipping, and adding Gaussian and K- noise were applied to increase dataset diversity and improve model generalization.
"""
reference = 'Pawłowska, A., Ćwierz-Pieńkowska, A., Domalik, A., Jaguś, D., Kasprzak, P., Matkowski, R., Fura, Ł., Nowicki, A., & Zolek, N. (2024). A Curated Benchmark Dataset for Ultrasound Based Breast Lesion Analysis (Breast-Lesions-USG) (Version 1) [dataset]. The Cancer Imaging Archive. https://doi.org/10.7937/9WKK-Q141'
release = '2024/01/08'  # Update date of the dataset
license_name = 'CC by 4.0'
license_url = 'https://creativecommons.org/licenses/by/4.0/'
license = f'Licensed under {license_name}. For more details, see {license_url}'
additional_params = {
    'patient_labels_file': '/content/BrEaST-Lesions-USG-clinical-data-Sep-2023-with-data-dictionary-v2-Nov-7-2023.xlsx',
}
num_training = 206
file_ending = '.nii.gz'

# Generate dataset JSON file
generate_dataset_json('/content/nnUNetFrame/dataset/nnUNet_raw/Dataset001_BreastTumor/dataset.json',
                      channel_names=channel_names,
                      labels=labels,
                      dataset_name=dataset_name,
                      description=description,
                      reference=reference,
                      release=release,
                      license=license,
                      additional_params=additional_params,
                      num_training=num_training,
                      file_ending=file_ending)

#To change the direction of the image to match the labels(ie. (1.0, 0.0, 0.0, 1.0))
import os
import SimpleITK as sitk

# Define the desired direction for the images
desired_direction = (1.0, 0.0, 0.0, 1.0)  # Desired direction for the images

# Define the directory paths for images and masks
image_dir = '/content/nnUNetFrame/dataset/nnUNet_raw/Dataset001_BreastTumor/imagesTr'

# Get list of image files
image_files = os.listdir(image_dir)

# Iterate through each image
for image_file in image_files:
    # Load image
    image_path = os.path.join(image_dir, image_file)
    image = sitk.ReadImage(image_path)

    print(f"Loaded image: {image_file}")

    # Check if the direction of the image matches the desired direction
    if image.GetDirection() != desired_direction:
        # Resample the image to match the desired direction
        image_resampled = sitk.Resample(image, image, sitk.Transform(), sitk.sitkNearestNeighbor, 0, image.GetPixelID())

        # Update the direction of the image
        image_resampled.SetDirection(desired_direction)

        print(f"Resampled image to match desired direction: {desired_direction}")

        # Save the resampled image
        sitk.WriteImage(image_resampled, image_path)

        print(f"Saved resampled image: {image_file}")

#To verify direction has been changed
import os
import SimpleITK as sitk

# Define the directory path for images
image_dir = '/content/nnUNetFrame/dataset/nnUNet_raw/Dataset001_BreastTumor/imagesTr'

# Get list of image files
image_files = os.listdir(image_dir)

# Iterate through each image
for image_file in image_files:
    # Load image
    image_path = os.path.join(image_dir, image_file)
    image = sitk.ReadImage(image_path)

    print(f"Image file: {image_file}")
    print(f"Direction after transformation: {image.GetDirection()}")

!nnUNetv2_plan_and_preprocess -d 1 --verify_dataset_integrity

!nnUNetv2_train -h

import os

# Set the GPU ID (change the ID as needed)
gpu_id = 0

# Set the CUDA_VISIBLE_DEVICES environment variable
os.environ["CUDA_VISIBLE_DEVICES"] = str(gpu_id)

# Define the argument values
dataset_name = "Dataset001_BreastTumor"
configuration = "2d"
folds = "all"  # Train on all folds
trainer = "nnUNetTrainer"
num_gpus = 1  # Adjust as needed

# Construct the command
command = f"nnUNetv2_train {dataset_name} {configuration} {folds} -tr {trainer} -num_gpus {num_gpus} --npz --val_best"

# Run the command
!{command}